"""
Plot BERT embeddings for skincare products and conditions.

This script visualizes the embeddings generated by BioBERT, ChemBERT, and SciBERT
using dimensionality reduction techniques (t-SNE and UMAP).
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
import seaborn as sns
from typing import Tuple, Dict
import argparse

# Import the BERT recommendation engines
from biobert_recommendation import SkincareRecommendationEngineBioBERT
from chembert_recommendation import SkincareRecommendationEngineChemBERT
from scibert_recommendation import SkincareRecommendationEngineSciBERT


def plot_embeddings_2d(embeddings: np.ndarray, labels: list, colors: list,
                       title: str, method: str = 'tsne', save_path: str = None):
    """
    Plot 2D visualization of embeddings.

    Args:
        embeddings: Embedding matrix (n_samples, embedding_dim)
        labels: List of labels for each embedding
        colors: List of colors for each embedding
        title: Plot title
        method: Dimensionality reduction method ('tsne' or 'umap')
        save_path: Optional path to save the plot
    """
    print(f"Reducing {embeddings.shape[0]} embeddings from {embeddings.shape[1]}D to 2D using {method.upper()}...")

    if method == 'tsne':
        reducer = TSNE(n_components=2, random_state=42, perplexity=min(30, len(embeddings)-1))
        embeddings_2d = reducer.fit_transform(embeddings)
    elif method == 'umap':
        try:
            import umap
            reducer = umap.UMAP(n_components=2, random_state=42)
            embeddings_2d = reducer.fit_transform(embeddings)
        except ImportError:
            print("UMAP not installed. Install with: pip install umap-learn")
            print("Falling back to t-SNE...")
            reducer = TSNE(n_components=2, random_state=42, perplexity=min(30, len(embeddings)-1))
            embeddings_2d = reducer.fit_transform(embeddings)
    else:
        raise ValueError(f"Unknown method: {method}. Use 'tsne' or 'umap'")

    # Create plot
    plt.figure(figsize=(12, 8))

    # Get unique labels and colors
    unique_labels = list(set(labels))
    color_map = {label: colors[labels.index(label)] for label in unique_labels}

    # Plot each group
    for label in unique_labels:
        mask = [l == label for l in labels]
        plt.scatter(
            embeddings_2d[mask, 0],
            embeddings_2d[mask, 1],
            c=[color_map[label]],
            label=label,
            alpha=0.6,
            s=100
        )

    plt.title(title, fontsize=16, fontweight='bold')
    plt.xlabel(f'{method.upper()} Component 1', fontsize=12)
    plt.ylabel(f'{method.upper()} Component 2', fontsize=12)
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()

    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Saved plot to {save_path}")

    plt.show()


def plot_condition_embeddings(engine, model_name: str, method: str = 'tsne'):
    """
    Plot embeddings for skin conditions (beneficial and harmful ingredients).

    Args:
        engine: BERT recommendation engine instance
        model_name: Name of the model (BioBERT, ChemBERT, SciBERT)
        method: Dimensionality reduction method
    """
    print(f"\n{'='*60}")
    print(f"Plotting {model_name} Condition Embeddings")
    print(f"{'='*60}")

    # Collect all embeddings and labels
    embeddings = []
    labels = []
    colors = []

    for condition in engine.get_supported_conditions():
        # Beneficial ingredients
        ben_embedding = engine.condition_embeddings[condition]
        embeddings.append(ben_embedding)
        labels.append(f"{condition} (Beneficial)")
        colors.append('green')

        # Harmful ingredients
        harm_embedding = engine.harmful_embeddings[condition]
        embeddings.append(harm_embedding)
        labels.append(f"{condition} (Harmful)")
        colors.append('red')

    embeddings = np.array(embeddings)

    title = f'{model_name} - Condition Ingredient Embeddings\n(Green=Beneficial, Red=Harmful)'
    save_path = f'{model_name.lower()}_condition_embeddings_{method}.png'

    plot_embeddings_2d(embeddings, labels, colors, title, method, save_path)


def plot_product_embeddings(engine, model_name: str, method: str = 'tsne',
                            sample_size: int = 500):
    """
    Plot embeddings for products colored by category.

    Args:
        engine: BERT recommendation engine instance
        model_name: Name of the model (BioBERT, ChemBERT, SciBERT)
        method: Dimensionality reduction method
        sample_size: Number of products to sample (for performance)
    """
    print(f"\n{'='*60}")
    print(f"Plotting {model_name} Product Embeddings")
    print(f"{'='*60}")

    # Sample products if dataset is large
    n_products = len(engine.product_embeddings)
    if n_products > sample_size:
        print(f"Sampling {sample_size} out of {n_products} products...")
        indices = np.random.choice(n_products, sample_size, replace=False)
        embeddings = engine.product_embeddings[indices]
        products_df = engine.products_df.iloc[indices]
    else:
        embeddings = engine.product_embeddings
        products_df = engine.products_df

    # Get labels and colors based on product category
    labels = products_df['Label'].tolist()

    # Create color palette
    unique_categories = products_df['Label'].unique()
    palette = sns.color_palette("husl", len(unique_categories))
    category_colors = {cat: palette[i] for i, cat in enumerate(unique_categories)}
    colors = [category_colors[label] for label in labels]

    title = f'{model_name} - Product Embeddings by Category'
    save_path = f'{model_name.lower()}_product_embeddings_{method}.png'

    plot_embeddings_2d(embeddings, labels, colors, title, method, save_path)


def plot_products_and_conditions(engine, model_name: str, condition: str,
                                 method: str = 'tsne', sample_size: int = 300):
    """
    Plot products and a specific condition's ingredients together.

    Args:
        engine: BERT recommendation engine instance
        model_name: Name of the model
        condition: Skin condition to visualize
        method: Dimensionality reduction method
        sample_size: Number of products to sample
    """
    print(f"\n{'='*60}")
    print(f"Plotting {model_name} Products + {condition} Condition")
    print(f"{'='*60}")

    # Sample products
    n_products = len(engine.product_embeddings)
    if n_products > sample_size:
        indices = np.random.choice(n_products, sample_size, replace=False)
        product_embeddings = engine.product_embeddings[indices]
    else:
        product_embeddings = engine.product_embeddings

    # Get condition embeddings
    ben_embedding = engine.condition_embeddings[condition]
    harm_embedding = engine.harmful_embeddings[condition]

    # Get top 3 recommendations for this condition
    recommendations = engine.recommend_top_3(condition)
    top_indices = [rec['index'] for rec in recommendations]

    # Combine embeddings
    embeddings = []
    labels = []
    colors = []

    # Add product embeddings
    for i in range(len(product_embeddings)):
        embeddings.append(product_embeddings[i])
        if i in top_indices:
            labels.append(f"Top {top_indices.index(i)+1} Product")
            colors.append('gold')
        else:
            labels.append("Product")
            colors.append('lightblue')

    # Add condition embeddings
    embeddings.append(ben_embedding)
    labels.append(f"{condition} (Beneficial)")
    colors.append('green')

    embeddings.append(harm_embedding)
    labels.append(f"{condition} (Harmful)")
    colors.append('red')

    embeddings = np.array(embeddings)

    title = f'{model_name} - Products & {condition} Condition\n(Gold=Top Recommendations, Green=Beneficial, Red=Harmful)'
    save_path = f'{model_name.lower()}_{condition.lower()}_products_{method}.png'

    plot_embeddings_2d(embeddings, labels, colors, title, method, save_path)


def main():
    parser = argparse.ArgumentParser(description='Visualize BERT embeddings for skincare products')
    parser.add_argument('--model', type=str, choices=['biobert', 'chembert', 'scibert', 'all'],
                       default='all', help='Which BERT model to use')
    parser.add_argument('--method', type=str, choices=['tsne', 'umap'],
                       default='tsne', help='Dimensionality reduction method')
    parser.add_argument('--plot-type', type=str,
                       choices=['conditions', 'products', 'combined', 'all'],
                       default='all', help='Type of plot to generate')
    parser.add_argument('--condition', type=str, default='Eczema',
                       help='Specific condition to visualize (for combined plot)')
    parser.add_argument('--sample-size', type=int, default=500,
                       help='Number of products to sample for visualization')

    args = parser.parse_args()

    # Model configurations
    models_config = {
        'BioBERT': {
            'class': SkincareRecommendationEngineBioBERT,
            'name': 'BioBERT'
        },
        'ChemBERT': {
            'class': SkincareRecommendationEngineChemBERT,
            'name': 'ChemBERT'
        },
        'SciBERT': {
            'class': SkincareRecommendationEngineSciBERT,
            'name': 'SciBERT'
        }
    }

    # Select models to plot
    if args.model == 'all':
        models_to_plot = list(models_config.keys())
    else:
        model_map = {
            'biobert': 'BioBERT',
            'chembert': 'ChemBERT',
            'scibert': 'SciBERT'
        }
        models_to_plot = [model_map[args.model]]

    # Generate plots for each model
    for model_key in models_to_plot:
        config = models_config[model_key]

        print(f"\n{'#'*60}")
        print(f"Loading {config['name']} Model...")
        print(f"{'#'*60}")

        # Initialize engine
        engine = config['class'](
            products_path='cosmetic_p.csv',
            conditions_path='dermatology_ingredients.csv'
        )

        # Generate requested plots
        if args.plot_type in ['conditions', 'all']:
            plot_condition_embeddings(engine, config['name'], args.method)

        if args.plot_type in ['products', 'all']:
            plot_product_embeddings(engine, config['name'], args.method, args.sample_size)

        if args.plot_type in ['combined', 'all']:
            plot_products_and_conditions(engine, config['name'], args.condition,
                                        args.method, args.sample_size)

    print("\n" + "="*60)
    print("Visualization complete!")
    print("="*60)


if __name__ == "__main__":
    main()
